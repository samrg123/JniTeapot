{"version":3,"file":"base.js","sourceRoot":"","sources":["../../src/transports/base.ts"],"names":[],"mappings":";AAAA,OAAO,EAA4B,MAAM,EAA+B,MAAM,kBAAkB,CAAC;AAsBjG,0CAA0C;AAC1C;IAcE,uCAAuC;IACvC,uBAA0B,OAAyB;QAAzB,YAAO,GAAP,OAAO,CAAkB;QANnD,mDAAmD;QAC3C,mBAAc,GAAS,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,CAAC;QAE1C,sBAAiB,GAAY,KAAK,CAAC;IAGS,CAAC;IAEvD,mCAAW,GAAX,UAAY,CAAU;QACpB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC7C,CAAC;IAED,4DAA4D;IAClD,0CAAkB,GAA5B;QACE,IAAM,OAAO,gBACR,IAAI,CAAC,OAAO,CAAC,OAAO,CACxB,CAAC;QAEF,IAAM,OAAO,GAET;YACF,KAAK,EAAE,IAAI,CAAC,MAAM;YAClB,OAAO,SAAA;YACP,MAAM,EAAE,MAAM;SACf,CAAC;QAEF,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,YAAY;IACI,uCAAe,GAA/B,UAAgC,UAAuB,EAAE,OAAgB;;;;gBACvE,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,GAAG,IAAI,CAAC,cAAc,EAAE;oBAC9C,sBAAO,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,2BAAyB,IAAI,CAAC,cAAc,+BAA4B,CAAC,CAAC,EAAC;iBAC5G;gBAED,sBAAO,IAAI,OAAO,CAAW,UAAC,OAAO,EAAE,MAAM;wBAC3C,IAAM,GAAG,GAAG,UAAU,CAAC,OAAO,CAAC,KAAI,CAAC,kBAAkB,EAAE,EAAE,UAAC,GAAyB;4BAClF,IAAM,UAAU,GAAG,GAAG,CAAC,UAAU,IAAI,GAAG,CAAC;4BACzC,IAAM,MAAM,GAAG,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;4BAE/C,GAAG,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;4BAExB,IAAI,MAAM,KAAK,MAAM,CAAC,OAAO,EAAE;gCAC7B,OAAO,CAAC,EAAE,MAAM,QAAA,EAAE,CAAC,CAAC;6BACrB;iCAAM;gCACL,IAAI,MAAM,KAAK,MAAM,CAAC,SAAS,EAAE;oCAC/B,IAAM,GAAG,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;oCACvB,KAAI,CAAC,cAAc,GAAG,IAAI,IAAI,CAAC,GAAG,GAAG,EAAE,GAAG,IAAI,CAAC,CAAC;iCACjD;gCACD,IAAI,gBAAgB,GAAG,iBAAe,UAAU,MAAG,CAAC;gCACpD,MAAM,CAAC,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC;6BACrC;4BAED,4BAA4B;4BAC5B,GAAG,CAAC,EAAE,CAAC,MAAM,EAAE;gCACb,QAAQ;4BACV,CAAC,CAAC,CAAC;4BACH,GAAG,CAAC,EAAE,CAAC,KAAK,EAAE;gCACZ,QAAQ;4BACV,CAAC,CAAC,CAAC;wBACL,CAAC,CAAC,CAAC;wBACH,GAAG,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;wBACxB,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;oBACnC,CAAC,CAAC,EAAC;;;KACJ;IAQH,oBAAC;AAAD,CAAC,AAjFD,IAiFC","sourcesContent":["import { Event, Payload, Response, Status, Transport, TransportOptions } from '@amplitude/types';\n\nimport * as http from 'http';\nimport * as https from 'https';\nimport * as url from 'url';\n\n/**\n * Internal used interface for typescript.\n * @hidden\n */\nexport interface HTTPRequest {\n  /**\n   * Request wrapper\n   * @param options These are {@see TransportOptions}\n   * @param callback Callback when request is finished\n   */\n  request(\n    options: http.RequestOptions | https.RequestOptions | string | url.URL,\n    callback?: (res: http.IncomingMessage) => void,\n  ): http.ClientRequest;\n}\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /** The Agent used for corresponding transport */\n  public module?: HTTPRequest;\n\n  public event?: Event;\n\n  /** The Agent used for corresponding transport */\n  public client?: http.Agent | https.Agent;\n\n  /** Locks transport after receiving 429 response */\n  private _disabledUntil: Date = new Date(Date.now());\n\n  protected _uploadInProgress: Boolean = false;\n\n  /** Create instance and set this.dsn */\n  public constructor(public options: TransportOptions) {}\n\n  sendPayload(_: Payload): PromiseLike<Response> {\n    throw new Error(`Method not implemented.`);\n  }\n\n  /** Returns a build request option object used by request */\n  protected _getRequestOptions(): http.RequestOptions | https.RequestOptions {\n    const headers = {\n      ...this.options.headers,\n    };\n\n    const options: {\n      [key: string]: any;\n    } = {\n      agent: this.client,\n      headers,\n      method: 'POST',\n    };\n\n    return options;\n  }\n\n  /** JSDoc */\n  protected async _sendWithModule(httpModule: HTTPRequest, payload: Payload): Promise<Response> {\n    if (new Date(Date.now()) < this._disabledUntil) {\n      return Promise.reject(new Error(`Transport locked till ${this._disabledUntil} due to too many requests.`));\n    }\n\n    return new Promise<Response>((resolve, reject) => {\n      const req = httpModule.request(this._getRequestOptions(), (res: http.IncomingMessage) => {\n        const statusCode = res.statusCode || 500;\n        const status = Status.fromHttpCode(statusCode);\n\n        res.setEncoding('utf8');\n\n        if (status === Status.Success) {\n          resolve({ status });\n        } else {\n          if (status === Status.RateLimit) {\n            const now = Date.now();\n            this._disabledUntil = new Date(now + 30 * 1000);\n          }\n          let rejectionMessage = `HTTP Error (${statusCode})`;\n          reject(new Error(rejectionMessage));\n        }\n\n        // Force the socket to drain\n        res.on('data', () => {\n          // Drain\n        });\n        res.on('end', () => {\n          // Drain\n        });\n      });\n      req.on('error', reject);\n      req.end(JSON.stringify(payload));\n    });\n  }\n\n  // /**\n  //  * @inheritDoc\n  //  */\n  // public close(timeout?: number): PromiseLike<boolean> {\n  //   return this._buffer.drain(timeout);\n  // }\n}\n"]}